### Pseudo istruzioni
#### Move
- E' fittizio 
- E' in realtà stato implementato come addizione senza segno fra il registro 16 e il registro 0

```js
addu $8, $0, $16                21: move $t0, $s0
```

#### Ble (branch if less than)
- E' fittizio 
- E' in realtà stato implementato set if less than. Nuovamente il risultato del set è scritto sul registro $1 che è $at
- Successivamente viene usato beq controllando $1 per decidere se saltare 0x0000001 (indirizzo memoria checkC)
- Da notare ancora beq confronta $1 con $0 (registro di tutti zero)

##### Ex. (trova il max di un vettore)

###### Codice assembly

```js
.data

vettore: .word 11, 35, 3, 17, 29, 95

N: .word 6

.text
	lw $to, vettore ($zero) //max ->$t0
	lw $t1, N //N -> $t1
	li $t2, 1 // i=1
	
for bge $t2, $t1, endFor  
	sl $t3, $t2, 2  //i*4
	lw $t4, vettore($t3) //el. = vettore [i] 
	ble $t4, $t0, else //if (el >= max)
	move     $to, $t4 // max = el

else:
	addi $t2, $t2, 1 //i++
	j for
endFor:
```

###### Codice C

```C
//definzione dato
int vettore[6] ={11, 35, 2, 17, 29, 95};
int N = 6;

int max = vettore[0];
//scandisco il vettore
for (i=1; i<N; i++)
{
	int el = vettore[i]; //el. corrente
	if (elememto > max)
		max = elemento;
}
```


#### Ciclo for

###### Esempio in C

```C
int N = 10;

for (i=0; i<N; i++)
{
	<codice da ripetere>
}

<codice seguente>
```

###### Esempio in Assembly

```js
.data

N: .half 10
.text

//uso il regitro $t0 per l'indice i 
//uso il regitro $t1 per il limite N

xor $t0, $t0, $t0 //azzero i
lhu $t1, N //limite del ciclo

cicloFor:
	bge $to, $t1, endFor //test i>=N
	<codice da ripetere>
	addi $t0, $t0, 1 //i+=1
	j cicloGor //jump back
endFor:
	<codice seguente>
```

#### Vettori e matrici

- Vettori: manipolazione con indici e con puntatori
- Matrici a 2,3 e N dimensioni
- Esempi di programmi

##### Vettore
- Sequenza di N elementi di dimensioni uguali
- Consecutivi in memoria
- Indirizzabili per indice (da 0 a N-1)
- Dimensione totale = N x Dimensione_elemento

>[!info] 
>- Si possono definire nella sezione `.data` del programma assembly usando un'etichetta per indicare l'indirizzo del primo elemento del vettore
>- Per indirizzare l'elemento i-esimo bisogna aggiungere l'offset 
>   i x Dimensione_elemento

#### Vettori di byte in memoria

###### Vettore di byte (valori interni da 0 a 255)

![[Screenshot 2024-03-15 120241.png]]

Testo: vettore di caratteri seguiti da \0 (carattere codificato con zero, 0x0)

```js
label2: .asciiz "sopra la panca"
```

Viene memorizzata come sequenza dei codici ASCII dei caratteri inseriti nella direttiva .asciiz

